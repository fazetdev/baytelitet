import { NextRequest, NextResponse } from 'next/server';
import dbConnect from '@/lib/db';
import Property from '@/lib/models/Property';
import { IProperty } from '@/lib/models/Property';

// Convert API request to MongoDB schema
const apiToDb = (data: any): Partial<IProperty> => {
  return {
    title: { 
      en: data.title || '', 
      ar: data.title || '' 
    },
    description: { 
      en: data.description || '', 
      ar: data.description || '' 
    },
    type: data.type || 'apartment',
    category: data.category || 'sale',
    price: data.price || 0,
    currency: data.currency || 'AED',
    beds: data.bedrooms || data.beds || 0,
    baths: data.bathrooms || data.baths || 0,
    area: {
      builtUp: data.area || 0,
      unit: data.areaUnit || 'sqft',
    },
    emirate: data.state || data.emirate || 'Dubai',
    city: data.city || '',
    location: {
      type: 'Point',
      coordinates: [data.lng || 55.2708, data.lat || 25.2048],
      address: { en: data.address || '', ar: data.address || '' },
      emirate: data.state || data.emirate || 'Dubai',
      city: data.city || '',
    },
    media: data.heroImage ? [{
      url: data.heroImage,
      type: 'image',
      order: 0,
      caption: { en: data.title || '', ar: data.title || '' }
    }] : [],
    coverImage: data.heroImage || '',
    agentId: data.agentId || new (require('mongoose')).Types.ObjectId(),
    commission: {
      percentage: data.commissionRate || 2.0,
      paymentTerms: 'Standard 30 days'
    },
    reraNumber: data.reraNumber || '',
    reraVerified: false,
    escrowRequired: data.escrowRequired || false,
    status: 'draft',
    isPublished: false,
    slug: { en: '', ar: '' },
    referenceNumber: `PROP-${Date.now().toString().slice(-6)}`,
    tags: [data.type, data.city].filter(Boolean),
  };
};

// Convert MongoDB document (plain object from lean()) to API response
const dbToApi = (property: any) => ({
  id: property._id?.toString(),
  title: property.title?.en || property.title || '',
  description: property.description?.en || property.description || '',
  type: property.type,
  category: property.category,
  price: property.price,
  currency: property.currency,
  bedrooms: property.beds,
  bathrooms: property.baths,
  area: property.area?.builtUp || 0,
  areaUnit: property.area?.unit || 'sqft',
  city: property.city,
  state: property.emirate,
  country: 'UAE',
  address: property.location?.address?.en || property.location?.address || '',
  lat: property.location?.coordinates?.[1],
  lng: property.location?.coordinates?.[0],
  heroImage: property.coverImage,
  gallery: property.media?.map((m: any) => m.url) || [],
  reraNumber: property.reraNumber,
  commissionRate: property.commission?.percentage || 0,
  agentName: '', // Would come from populated agent
  agentLicense: '', // Would come from populated agent
  complianceStatus: property.reraVerified ? 'verified' : 'pending',
  isPublished: property.isPublished,
  status: property.status,
  createdAt: property.createdAt,
  updatedAt: property.updatedAt,
});

export async function GET(request: NextRequest) {
  try {
    await dbConnect();
    
    const { searchParams } = new URL(request.url);
    const query: any = {};
    
    // Apply filters
    const type = searchParams.get('type');
    if (type && type !== 'all') query.type = type;
    
    const city = searchParams.get('city');
    if (city && city !== 'all') query.city = new RegExp(city, 'i');
    
    const minPrice = searchParams.get('minPrice');
    const maxPrice = searchParams.get('maxPrice');
    if (minPrice || maxPrice) {
      query.price = {};
      if (minPrice) query.price.$gte = Number(minPrice);
      if (maxPrice) query.price.$lte = Number(maxPrice);
    }
    
    // Only show published properties for public API
    query.isPublished = true;
    query.status = 'published';
    
    const properties = await Property.find(query)
      .sort({ createdAt: -1 })
      .limit(50)
      .lean();
    
    return NextResponse.json(properties.map(dbToApi));
    
  } catch (error) {
    console.error('GET /api/properties error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch properties' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    await dbConnect();
    
    const data = await request.json();
    
    // Validate required fields
    const required = ['title', 'price', 'type', 'city', 'reraNumber'];
    const missing = required.filter(field => !data[field]);
    
    if (missing.length > 0) {
      return NextResponse.json(
        { error: `Missing required fields: ${missing.join(', ')}` },
        { status: 400 }
      );
    }
    
    // Transform and save
    const propertyData = apiToDb(data);
    const property = await Property.create(propertyData);
    
    return NextResponse.json(dbToApi(property.toObject()), { status: 201 });
    
  } catch (error: any) {
    console.error('POST /api/properties error:', error);
    
    if (error.code === 11000) {
      return NextResponse.json(
        { error: 'Duplicate property reference or slug' },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { error: 'Failed to create property', details: error.message },
      { status: 500 }
    );
  }
}
